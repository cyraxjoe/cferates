import http
import inspect
from dataclasses import dataclass
from pprint import pformat

import requests
from bs4 import BeautifulSoup


class AbstractStatefulField:

    def __init__(self, field_name: str, initial_value: str = "", update: bool = True):
        self.name = field_name
        self.initial_value = ""
        self.update = update

    def __set_name__(self, owner_cls, name):
        try:
            class_field_registry = owner_cls._cls_fields[owner_cls]
        except AttributeError:
            # fist use, initiate the registry
            class_field_registry = {}
            owner_cls._cls_fields = {owner_cls: class_field_registry}
        except KeyError:
            # new class, we already have the registry attribute
            class_field_registry = owner_cls._cls_fields[owner_cls] = {}
        class_field_registry[self.name] = self.initial_value

    def __set__(self, owner_inst, value):
        """
        If `value` is a BeautifulSoup instance
        look for the field in the soup and use that
        as the value.

        Otherwise, assign the value directly into the internal state,
        of the instance.
        """
        if isinstance(value, BeautifulSoup):
            if self.update: # if update is False, just ignore the value.
                self._update_from_soup(owner_inst, value)
        else:
            owner_inst._internal_state[self.name] = value

    def __get__(self, owner_inst, owner_cls):
        if owner_inst is None:
            return self
        else:
            return owner_inst._internal_state[self.name]

    def _update_from_soup(self, owner_inst, soup):
        results = soup.select(self.css_selector)
        if not results:
            raise Exception(
                f"The css selector '{ self.css_selector }' didn't return anything for { self.name }"
            )
        value = results.pop()["value"].strip()
        if value:
            owner_inst._internal_state[self.name] = value
        else:
            raise Exception(f"Unable to obtain the value of { self.name }")

    @property
    def css_selector(self):
        raise NotImplementedError(
            "The class is not fully defined, there is no css selector.")


class HiddenField(AbstractStatefulField):

    @property
    def css_selector(self):
        return f'input[name="{ self.name }"]'

class SelectField(AbstractStatefulField):

    @property
    def css_selector(self):
        return f'select[name="{ self.name }"] > option[selected]'

class AbstractForm:
    ## base state managers in the form, after each interaction
    ## with the backend
    view_state = HiddenField("__VIEWSTATE")
    view_state_generator = HiddenField("__VIEWSTATEGENERATOR")
    event_validation = HiddenField("__EVENTVALIDATION")
    ###
    event_target = HiddenField("__EVENTTARGET", update=False)
    event_argument = HiddenField("__EVENTARGUMENT", update=False)
    last_focus = HiddenField("__LASTFOCUS", update=False)

    def __init__(self):
        self._configure_internal_state()
        self._configure_stateful_fields()

    def _configure_internal_state(self):
        # get all the parent classes including
        # this instance. Exclude the last one (the base object).
        parents = inspect.getmro(self.__class__)[:-1]
        internal_state = {}
        for cls in reversed(parents):
            # _cls_fields gets generated by the fields
            # as part of the class definition
            try:
                internal_state.update(self._cls_fields[cls])
            except KeyError:
                pass # the ancestor didn't defiend any field
        self._internal_state = internal_state

    def _configure_stateful_fields(self):
        stateful_fields = []
        for field_name in dir(type(self)):
            if not field_name.startswith("_"):
                if isinstance(getattr(self.__class__, field_name), AbstractStatefulField):
                    stateful_fields.append(field_name)
        self.stateful_fields = tuple(stateful_fields)

    def __repr__(self):
        return "{}<{}>\n{}".format(
            self.__class__.__name__,
            id(self),
            pformat(self._internal_state)
        )

    def __str__(self):
        return pformat(self._internal_state)

    def __call__(self, target):
        """
        Return a dictionary with all the parameters expected to be
        received by the form.

        Given the expected stateful form dynamics, we need a "target"
        fieldname and any extra field passwd as kwargument will be
        included in the dictionary.
        """
        self.event_target = target.name
        return dict(self._internal_state)

    def __lt__(self, soup):
        """
        Cute little operator definition to use the expression: `form < soup`
        """
        self.update_internal_state(soup)

    def update_internal_state(self, soup):
        for field_name in self.stateful_fields:
            setattr(self, field_name, soup)

class AbstractStatefulScraper:
    main_url = None
    FormCls = AbstractForm
    base_headers = {
        'User-Agent': "Mozilla/5.0 (Windows NT 10.0; WOW64; rv:67.0) Gecko/20100101 Firefox/67.0"
    }

    def __init__(self, do_initial_request=True, prev_session=None):
        if self.main_url is None:
            raise Exception("The main URL can't be None.")
        self.form = self.FormCls()
        if prev_session is not None:
            self.req_session = prev_session
        else:
            self.req_session = requests.Session()
        self.req_session.headers.update(self.base_headers)
        if do_initial_request:
            self.http_get_request()

    def _make_stateful_request(self, method='get', **extr_params):
        """
        Make a http request (get/post) to the main URL `self.main_url`,
        update the internal state (view_state among other things),
        and return a BeatifulSoup instance with content.
        """
        norm_method = method.lower()
        if norm_method not in ('get', 'post'):
            raise Exception(f"The method { method } is not supported")
        if method == 'get':
            response = self.req_session.get(self.main_url, **extr_params)
        else:
            response = self.req_session.post(self.main_url, **extr_params)
        if response.status_code != http.HTTPStatus.OK:
            raise Exception(f"Unable to obtain the initial page. { response }")
        soup = BeautifulSoup(response.text, 'lxml')
        self.form.update_internal_state(soup)
        return soup

    def http_get_request(self, **kwargs):
        return self._make_stateful_request('get', **kwargs)

    def http_post_request(self, data, **kwargs):
        return self._make_stateful_request('post', data=data, **kwargs)
