import http
import enum
import inspect
from pprint import pformat

import requests
from bs4 import BeautifulSoup


class FieldType(enum.Enum):
    select = enum.auto()
    hidden = enum.auto()


class AbstractStatefulField:

    def __init__(self, field_type: FieldType, field_name: str, initial_value=""):
        self.ftype = field_type
        self.name = field_name
        self.initial_value = ""

    def __set_name__(self, owner_cls, name):
        try:
            class_field_registry = owner_cls._cls_fields[owner_cls]
        except AttributeError:
            # fist use, initiate the registry
            class_field_registry = {}
            owner_cls._cls_fields = {owner_cls: class_field_registry}
        except KeyError:
            # new class, we already have the registry attribute
            class_field_registry = owner_cls._cls_fields[owner_cls] = {}
        class_field_registry[self.name] = self.initial_value

    def __set__(self, owner_inst, value):
        """
        If `value` is a BeautifulSoup instance
        look for the field in the soup and use that
        as the value.

        Otherwise, assign the value directly into the internal state,
        of the instance.
        """
        if isinstance(value, BeautifulSoup):
            self._update_from_soup(owner_inst, value)
        else:
            owner_inst._internal_state[self.name] = value

    def __get__(self, owner_inst, owner_cls):
        if owner_inst is None:
            return self
        else:
            return owner_inst._internal_state[self.name]

    def _update_from_soup(self, owner_inst, soup):
        value = soup.select("#" + self.name).pop()["value"].strip()
        if value:
            owner_inst._internal_state[self.name] = value
        else:
            raise Exception(
                "Unable to obtain the value of {}".format(self.name))

class HiddenField(AbstractStatefulField):
    def __init__(self, field_name, initial_value=""):
        super().__init__(FieldType.hidden, field_name, initial_value)


class SelectField(AbstractStatefulField):
    def __init__(self, field_name, initial_value=""):
        super().__init__(FieldType.select, field_name, initial_value)

class AbstractForm:
    ## base state managers in the form, after each interaction
    ## with the backend
    view_state = HiddenField("__VIEWSTATE")
    view_state_generator = HiddenField("__VIEWSTATEGENERATOR")
    event_validation = HiddenField("__EVENTVALIDATION")
    ###
    event_target = HiddenField("__EVENTTARGET")
    event_argument = HiddenField("__EVENTARGUMENT")
    last_focus = HiddenField("__LASTFOCUS")

    def __init__(self):
        self._configure_internal_state()

    def _configure_internal_state(self):
        # get all the parent classes including
        # this instance. Exclude the last one (the base object).
        parents = inspect.getmro(self.__class__)[:-1]
        internal_state = {}
        for cls in reversed(parents):
            # _cls_fields gets generated by the fields
            # as part of the class definition
            try:
                internal_state.update(self._cls_fields[cls])
            except KeyError:
                pass # the ancestor didn't defiend any field
        self._internal_state = internal_state

    def __repr__(self):
        return "{}<{}>\n{}".format(
            self.__class__.__name__,
            id(self),
            pformat(self._internal_state)
        )

    def __str__(self):
        return pformat(self._internal_state)

    def __call__(self, target):
        """
        Return a dictionary with all the parameters expected to be
        received by the form.

        Given the expected stateful form dynamics, we need a "target"
        fieldname and any extra field passwd as kwargument will be
        included in the dictionary.
        """
        self.event_target = target.name
        return dict(self._internal_state)



class AbstractStatefulScraper:
    main_url = None
    FormCls = AbstractForm
    base_headers = {
        'User-Agent': "Mozilla/5.0 (Windows NT 10.0; WOW64; rv:67.0) Gecko/20100101 Firefox/67.0"
    }

    def __init__(self, do_initial_request=True, prev_session=None):
        if self.main_url is None:
            raise Exception("The main URL can't be None.")
        self.form = self.FormCls()
        if prev_session is not None:
            self.req_session = prev_session
        else:
            self.req_session = requests.Session()
        self.req_session.headers.update(self.base_headers)
        if do_initial_request:
            self.http_get_request()

    def _update_internal_state(self, soup):
        self.form.view_state = soup
        self.form.view_state_generator = soup
        self.form.event_validation = soup

    def _make_stateful_request(self, method='get', **extr_params):
        """
        Make a http request (get/post) to the main URL `self.main_url`,
        update the internal state (view_state among other things),
        and return a BeatifulSoup instance with content.
        """
        norm_method = method.lower()
        if norm_method not in ('get', 'post'):
            raise Exception("The method {} is not supported".format(method))
        if method == 'get':
            response = self.req_session.get(self.main_url, **extr_params)
        else:
            response = self.req_session.post(self.main_url, **extr_params)
        if response.status_code != http.HTTPStatus.OK:
            raise Exception("Unable to obtain the initial page. {}".format(response))
        soup = BeautifulSoup(response.text, 'lxml')
        self._update_internal_state(soup)
        return soup

    def http_get_request(self, **kwargs):
        return self._make_stateful_request('get', **kwargs)

    def http_post_request(self, data, **kwargs):
        return self._make_stateful_request('post', data=data, **kwargs)
